module Expression

imports
  
  Common
  ID
  Type

template options
    tokenize: "(;{[,.!"
    keyword -/- [a-zA-Z0-9]

context-free start-symbols
  Exp
  
context-free priorities
	{Exp.Lambda}								>
	{Exp.InlineIf}						 		> 	
	{Exp.Or}									>
	{Exp.And} 								>
	{Exp.Not} 									>
	{Exp.In Exp.NotIn Exp.Is 
	 Exp.IsNot Exp.In Exp.Lt
	 Exp.Leq Exp.Gt Exp.Geq 
	 Exp.Neq Exp.Neq2 Exp.Eq} 			>
	{Exp.BitOr}								>
	{Exp.BitXor}								>
	{Exp.BitAnd}								>
//	{Exp.BitLShift Exp.BitRShift}			>
	{Exp.Add Exp.Sub}						>
	{Exp.Mul Exp.MatMul 
	 Exp.Div Exp.IntDiv Exp.Mod}			>
	{Exp.Pos Exp.Neg Exp.Inv}				>
	{Exp.Pow}									//>
//	{Exp.Await}									>
//	{Exp.Subscript Exp.Slice 
//	 Exp.Call Exp.attrRef}						>
//	{Exp.Tuple Exp.List Exp.Dict Exp.Set}
	
context-free syntax
	Exp	= < (<Exp>) >	{bracket}

    Exp.LeftShift  = Exp "<<" Exp		{left}
    Exp.RightShift = Exp ">>" Exp		{left}
    Exp.Add 		 = Exp "+"  Exp		{left}
    Exp.Sub 		 = Exp "-"  Exp		{left}
    Exp.Mul 		 = Exp "*"  Exp		{left}
    Exp.MatMul	 = Exp "@"  Exp		{left}
    Exp.Div 		 = Exp "/"  Exp		{left}
    Exp.Mod 		 = Exp "%"  Exp		{left}
    Exp.IntDiv 	 = Exp "//" Exp		{left}
    Exp.Pow		 = Exp "**" Exp		{left}
  
    Exp.Lt    = Exp "<"  Exp			{left}
    Exp.Gt    = Exp ">"  Exp			{left}
    Exp.Eq    = Exp "==" Exp			{left}
    Exp.Geq   = Exp ">=" Exp			{left}
    Exp.Leq   = Exp "<=" Exp			{left}
    Exp.Neq   = Exp "!=" Exp			{left}
    Exp.Neq2  = Exp "<>" Exp			{left}
    Exp.In    = Exp "in" Exp			{left}
    Exp.Is    = Exp "is" Exp			{left}
    Exp.IsNot = Exp "is" "not" Exp	{left}
    Exp.NotIn = Exp "not" "in" Exp	{left}
    
    Exp.And = Exp "and" Exp	{left}
    Exp.Or  = Exp "or"  Exp	{left}
    Exp.Not  = "not" Exp	    {right}
    Exp.Pos  = "+" Exp	   		{right}
    Exp.Neg  = "-" Exp	   		{right}
    Exp.Inv  = "~" Exp	   		{right}
    
    Exp.BitOr      = Exp "|"  Exp			{left}
    Exp.BitXor     = Exp "^"  Exp			{left}
    Exp.BitAnd     = Exp "&"  Exp			{left}
    Exp.BitLShift  = Exp "<<" Exp			{left}
    Exp.BitRShift  = Exp ">>" Exp			{left}
    
    Exp.Lambda = "lambda"
    Exp.InlineIf = "if"
    
  
  	Exp.False = "False"
    Exp.True = "True"
    Exp.NoneVal = "None"
    Exp.ThreeDot = "..."
    Exp.String = STRING
    Exp.Int = INT
    Exp.Float = FLOAT
    Exp.ID = ID
//    Atom.YieldOrTestList = "(" YieldOrTestList ")"
//    Atom.DictOrSet = "{" NewLine? DictOrSetMaker? NewLine? "}"
//    Atom.TestListComp = "[" TestListComp? "]"

  //  PossibleStarExp.Exp = Exp
//  PossibleStarExp.StarExp = StarExp 
//  
//  ExpressionList.List = {PossibleStarExp ","}+ Comma?
//
//  StarExp.StarExp = "*" Exp
//  
//  ExpList.List = {PossibleStarExp ","}+ Comma?
//  Exp.Exp = {XorExp "|"}+
//  XorExp.XorExp = {AndExp "^"}+
//  AndExp.AndExp = {ShiftExp "&"}+
//  ShiftExp.ShiftExp = ArithExp ArithExpNode*
//  ArithExp.ArithExp = Term TermNode*
//  Term.Term = Factor FactorNode*
//  Factor.Pos = "+" Factor 
//  Factor.Neg = "-" Factor 
//  Factor.Inv = "~" Factor 
//  Factor.Power = Power 
//  Power.Power = AtomExp PowerNode?
//  AtomExp.AtomExp = Await? Atom Trailer*
//
//  Trailer.ArgList = "(" ArgList? ")"
//  Trailer.SubscriptList = "[" {Subscript ","}+ Comma? "]"
//  Trailer.DotName = "." ID
//
//  DictOrSetMaker.DictMaker = DictContents DictContentsNode* Comma?
//  DictOrSetMaker.SetMaker = TestListComp
//
//  TestListComp.TestListComp = TestListCompContents TestListCompNode* Comma?
//
//  TestListCompNode.SetContents = "," TestListCompContents
//  TestListCompNode.CompFor = CompFor
// 
//  TestListCompContents.Test = Test
//  TestListCompContents.StarExp = StarExp
//  
//  DictContents.KeyValuePair = Test ":" Test
//  DictContents.DictKwargs = "**" Exp
//  
//  DictContentsNode.DictContents = "," NewLine? DictContents
//  DictContentsNode.CompFor = CompFor
//  
//  YieldOrTestList.Yield = Yield
//  YieldOrTestList.TestList = TestList