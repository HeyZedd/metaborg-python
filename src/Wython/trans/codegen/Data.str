module Data

imports
  signatures/WebAssembly/-
  ast-syntax/-
  trans/codegen/-
  
rules

  data:
    stmts -> dataList
    where 
    lengths := <map(calculate-length)> stmts;
    <debug> ("data, lengths:", lengths);
    offsets := <calculate-offset> lengths;
    <debug> ("data, offsets:", offsets);
    dataList := <concat> <map(dataStmt)> <zip> (stmts, offsets)

    
    
  calculate-length:
  	If(condition, body, else) -> lengths
  	where
  	bodyLengths :=  <map(calculate-length)> body;
  	elseLengths :=  <map(calculate-length)> else;
  	lengths :=  [ bodyLengths, elseLengths ]

  calculate-length:
    ExprStmt(Call(_, args, _)) -> length
  	where
  	length := <map(calculate-length)> args
  		
  calculate-offset:
    [list] -> result
    where 
    <debug> ("Calculate offset, list:", list);
    result := [<calculate-offset> (list, 0)]

  calculate-offset:
    ([], _) -> []
    where 
    <debug> ("Calculate offset")
    
  calculate-offset:
    ([h|t], s) -> [hh | <calculate-offset> (t, sum)] 
    where 
    <debug> ("Calculate offset, h:", h);
    <debug> ("Calculate offset, t:", h);
	  (hh, sum) := <offset-unpack> (h, s)

  offset-unpack:
    ([val], sum) -> ([v], s) where (v, s) := <offset-unpack>(val, sum)
  offset-unpack:
    (val, sum) -> (<int-to-string> sum, <addi> (sum, <string-to-int> val))
  
    	
  calculate-length:
  	String(s) -> length
  	where
  	length := [ <int-to-string> <string-length> s ]
    
  dataStmt:
  	(If(condition, body, else), [ bodyLengths, elseLengths] ) -> dataList
  	where
      dataList := <concat> [
  		<concat> <map(dataStmt)> <zip> (body, bodyLengths),
  		<concat> <map(dataStmt)> <zip> (else, elseLengths)
  	]

  dataStmt: 
    (ExprStmt(Call(name, args, kwargs)), offsets)
       -> dataList 
    where
      dataList := <concat> <map(dataParam)> <zip> (args, offsets)

  dataParam:
    (param, [offset]) -> [
       WastData(
          WastExpr(WastInstr(I32Const(offset))), 
          Some(val)
        )]
    where
      <debug> offset;
      val := <to-string> param
       
  to-string:
    Int(val) -> string
      where
      //string := val
      string := <int-to-string> val

  to-string:
    Num(val) -> string
      where
      string := <real-to-string> val
    
  to-string:
    String(val) -> val
