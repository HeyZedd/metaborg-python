module Memory

imports
  signatures/WebAssembly/-
  ast-syntax/-
  trans/codegen/-
  
rules

  calculate-length:
    FunctionDef(_,_,body,_,_) -> <map(calculate-length)> body
          
  calculate-length:
  	If(condition, body, []) -> lengths
  	where
  	bodyLengths :=  <map(calculate-length)> body;
  	lengths :=  [ bodyLengths ]

  calculate-length:
  	If(condition, body, else) -> lengths
  	where
  	bodyLengths :=  <map(calculate-length)> body;
  	elseLengths :=  <map(calculate-length)> else;
  	lengths :=  [ bodyLengths, elseLengths ]

  calculate-length:
  	If(condition, body, else) -> lengths
  	where
  	bodyLengths :=  <map(calculate-length)> body;
  	elseLengths :=  <map(calculate-length)> else;
  	lengths :=  [ bodyLengths, elseLengths ]

  calculate-length:
    ExprStmt(Call(_, args, _)) -> length
  	where
  	length := <map(calculate-length)> args
  		
  calculate-length:
  	Int(s) -> length
  	where
  	<debug> s;
  	length := [ <int-to-string> <string-length> <int-to-string> <string-to-int> s ]
    	
  calculate-length:
  	String(s) -> length
  	where
  	length := [ <int-to-string> <addi> (<string-length> s, -2) ]
  	// -2 to compensate for the quotation marks
    
  calculate-offset:
    [h | t] -> result
    where 
    <debug> ("Calculate offset 1, h:", h);
    <debug> ("Calculate offset 1, t:", h);
    result := <calculate-offset> ([h | t], 0)

  calculate-offset:
    ([], _) -> []
    where 
    <debug> ("Calculate offset 2")
    
  calculate-offset:
    ([h|t], s) -> [hh | <calculate-offset> (t, sum)] 
    where 
    <debug> ("Calculate offset 3, h:", h);
    <debug> ("Calculate offset 3, t:", h);
	  (hh, sum) := <offset-unpack> (h, s)
	  
  calculate-offset:
    [list] -> result
    where 
    <debug> ("Calculate offset 4, list:", list);
    result := [<calculate-offset> (list, 0)]

  calculate-offset:
    ([list], s) -> result
    where 
    <debug> ("Calculate offset 5, list:", list);
    result := [<calculate-offset> (list, s)]

	calculate-offset:
	 e -> <debug> ("Error: ", e)

  offset-unpack:
    ([val], sum) -> ([v], s) where (v, s) := <offset-unpack>(val, sum)
  offset-unpack:
    (val, sum) -> (<int-to-string> sum, <addi> (sum, <string-to-int> val))
  
