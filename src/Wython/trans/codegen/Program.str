module Program

imports
  signatures/WebAssembly/-
  signatures/WebAssembly-sig
  trans/codegen/-
  ast-syntax/-

strategies
  codegen-all = codegen
 
rules
  lib-funcs: _ -> [
  	WastFunc( Some("$print"), WastImport("\"lib\"", "\"logString\""), Some(WastParams([I32(), I32()]))),
  	WastFunc( Some("$debug"), WastImport("\"debug\"", "\"debugger\""), Some(WastParams([I32(), I32()])))
  ]
  init-memory: _ -> [
  	WastMem(Some("$d"), WastImport("\"memory\"", "\"memory\""), "1")
  ]
  
  codegen: Module(stmts) -> WastFile([WastModule(<concat>[<lib-funcs>, <init-memory>, iList], dList, fList, eList, init)], "")
    where
	   mainBody := <filter(not(?is-func))> stmts;
	   functions := <filter(is-func)> stmts;
	   all_functions := <concat> [functions, [FunctionDef("main", Arguments([], [], [], [], [], []), mainBody, None(), None())]];
       (iList, dList, fList, eList, vars, memSize) := <foldl(codegen-func)> (all_functions, ([], [], [], [], [], 0));
       <debug> ("Memory size", memSize);
       init := WastStart("$main")

  is-func: FunctionDef(a,b,c,d,e) -> FunctionDef(a,b,c,d,e)
  
  wast-add-import(wast): (imp, mem) -> (<concat>[i, [imp]], d, f, e, v, mptr)
    where 
      (i, _, _, e, v, _) := <wast>;
      (d, f, _, mptr) := mem
    
  wast-add-data(wast): (data, mem) -> (i, <concat>[d, [data]], f, e, v, mptr)
    where 
      (i, _, _, e, v, _) := <wast>;
      (d, f, _, mptr) := mem
    
  wast-add-func(wast): (func, mem) -> (i, d, <concat>[f, [func]], e, v, mptr)
    where
      (i, _, _, e, v, _) := <wast>;
      (d, f, _, mptr) := mem
    
  wast-add-expr(wast): (expr, mem) -> (i, d, f, <concat>[e, [expr]], v, mptr)
    where
      (i, _, _, e, v, _) := <wast>;
      (d, f, _, mptr) := mem
    
  codegen-func: (FunctionDef(name, args, body, decorators, None()), wast) -> <wast-add-func(!wast)> (func, mem)
  	where
  	  (_, data, funcs, _, vars, mptr) := wast;
  	  (funcbody, mem) := <foldl(codegen-stmt)> (body, ([], (data, funcs, vars, mptr)));
  	  func := WastFunc(Some(<concat-strings> ["$", name]), <codegen-func>args, funcbody)
  	  
  codegen-func: (FunctionDef(name, args, body, decorators, return), wast) -> <wast-add-func(!wast)> (func, size)
  	where
  	  (_, data, funcs, _, vars, mptr) := wast;
  	  (funcbody, size) := <foldl(codegen-stmt)> (<concat> [body, [return]], ([], (data, funcs, vars, mptr)));
  	  func := WastFunc(Some(<concat-strings> ["$", name]), <codegen-func> args, funcbody)
  
  codegen-func: Arguments(args, _, _, _, _, _) -> <map(codegen-func)> args
  codegen-func: Arg(ID(name), _) -> WastParam(Some(<concat-strings> ["$", name]), WastI32())
  codegen-func: e -> <debug> e
  
  mem-add-string: ((data, funcs, vars, mptr), val) -> (mptr, len, (new-data, funcs, vars, new-mptr))
    where
      new-data := <concat> [data, [WastData(WastI32Const(<int-to-string> mptr), Some(val))]];
      len := <subti>(<string-length> val, 2);
      new-mptr := <addi> (mptr, len)
      
  // Add existing var -> do nothing
  mem-add-var: ((data, funcs, vars, mptr), var) -> ([], (data, funcs, vars, mptr))
    where
      (name, type) := var;
      new-var := <set-eq> (vars, <union> (vars, [name]));	//Fails when adding new var
      <debug> ("Vardecl already defined for ", name)
      
  // Add new var -> do something     
  mem-add-var: ((data, funcs, vars, mptr), var) -> (w-vardecl, (data, funcs, <concat>[vars, [name]], mptr))
    where
      (name, type) := var;
      <debug> ("Adding new vardecl for ", name);
      w-vardecl := [WastLocal(Some(name), type)]
  
  