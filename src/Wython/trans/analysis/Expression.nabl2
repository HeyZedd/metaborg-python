module analysis/Expression

imports
  desugar/-
  analysis/-
      
rules

  Expr[[ Name(ID(a), Load()) ^(s): ty]] := 
    Var{a} -> s,
    Var{a} |-> d | warning $[Variable [a] might not be defined] @a,
    d: ty.
    
  argument[[(ID(i), expr) ^(s) : ty]] :=
    //TODO: try to check if argument match function definition
    Expr[[expr ^(s): ty]].

  Expr[[ Call(func, args, kargs) ^(s) : rtype]] :=
    Expr[[func  ^(s) : objType]],

    objType == CallableT(argTypes, rtype) | warning $[Object might not be callable],
    Map1T(argument)[[args  ^(s): argtys]],
    Map1T(argument)[[kargs ^(s): kargtys]].
    
    
  // Arithmatic Expressions
  Expr[[BinOp(op, l, r) ^(s): ty]] :=
    Expr[[l ^(s): t1]],
    Expr[[r ^(s): t2]],
    t2 == t1 | error $[Types not equal: [t1] != [t2]],
    ty == t1.


  // Atoms
  Expr[[Int(_) ^(s): IntT()]].
  Expr[[String(_) ^(s): StringT()]].
  Expr[[True() ^(s): BoolT()]].
  Expr[[False() ^(s): BoolT()]].
  
  
  